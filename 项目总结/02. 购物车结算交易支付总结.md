## 购物车

### 添加商品到购物车

1. 在detail页面，选中商品与数量后，单击**添加购物车**需要发送请求，跳转到添加购物车成功页面
2. 成功组件需要用到商品信息所以跳转路由要保存商品信息 ，用sessionStorage保存，还需要携带一个query参数skuNum。

### 使用UUID

#### 原因

1. 正常情况下，每次发送请求的时候，都应该在请求头中携带一个唯一的身份标识
2. 如果是正常注册登陆的用户应该使用`token`，来识别每个用户的身份，这个'token'由服务器端生成
3. 而我们现在是没有注册登陆，此时也可以添加购物车 但是购物车中没有任何数据，因为没有唯一的身份标识
4. 为了能够在不登陆的情况下，也能够添加购物车或是查看购物车的时候，应该发给服务器一个临时身份ID
5. 这个临时身份ID也应该是唯一的，是在浏览器端生成的，在请求头中跟随请求一并发送给服务器
6. 服务器端是根据你的**请求头**中的临时id来辨别每一个不同的人

### 渲染数据

- 用三连环发请求、获取数据，展示数据（需要计算）

- 交互：更新购物车数量数据、更新购物车选中状态数据、删除购物车数据


## 点击购物车到交易页面

1. 点击购物车结算会到订单交易页面。
2. 在交易页获取交易信息和用户地址信息，两个请求。
3. api写请求方法，用三连环发请求、获取数据，展示数据，完成交互。



## 点击交易页面的提交到订单支付页面

1. 先通过交易编号发请求创建订单。
2. 成功返回订单编号，然后把订单编号携带路由跳转到订单支付页面。



## 支付页面也需要支付信息

1. 在beforeMount里面将订单编号存储到data上，mounted根据订单编号发送请求获取支付信息，页面展示订单编号和订单编号。
2. 订单编号信息也可以直接通过query参数获取到。



## 点击订单支付会出现一个支付二维码

1. element-ul按需引入。
2. 支付信息包含一个codeUrl，是用来生成二维码的。
3. 安装node-qrcode，用于把返回的图片地址生成二维码。



## 支付流程

1. 生成二维码。
2. messageBox展示二维码。
3. 立马轮询，每隔2秒发一次，去查询支付状态是否支完成。
4. 后台会在发请求后返回支付状态码 ，支付状态码如果是205代表还在支付中，如果是200代表支付成功。
5. 根据返回的状态码绝对后续操作。
   1. 如果是200的时候，我们要自动跳转到支付成功页面，关闭messageBox,并且清除定时器让变量也为null。
   2. 把这个状态码还要保存在data当中，用来去作为用户点击已成功支付按钮的判断依据。
6. 去单独的处理点击我已成功支付或者支付遇到问题按钮的逻辑。
   1. 点击我已成功支付，那么要根据data当中存储的状态码判断是否真的支付完成，如果没有完成，停在当前页面并提示用户,不关闭messageBox。
   2. 点击支付遇到问题，那么我们要提示用户找谁处理，停止往后台发请求，关闭定时器让变量也为null。



## 生命周期

1. `beforeCreate`：无法通过vm访问到data中的数据、methods中的方法。
2. beforeCreate和created之间数据代理，数据劫持
3. `created`：可以通过vm访问到data中的数据、methods中的方法。
4. `beforeMoute`：不能通过ref拿到真实DOM`
5. `Mouted`：可以通过ref拿到真实DOM
6. `beforeUpdate`：data更新了，页面还没更新
7. `Updated`：都更新了
8. `$destroyed`: 通过调用这个方法触发最后两个生命周期方法
9. `beforeDestroy`：一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。
10. `destroyed`：组件真的被销毁了