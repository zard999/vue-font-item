## 点击购物车到交易页面

1. 点击购物车结算会到订单交易页面。
2. 在交易页获取交易信息和用户地址信息，两个请求。
3. api写请求方法，用三连环发请求、获取数据，展示数据，完成交互。



## 点击交易页面的提交到订单支付页面

1. 先通过交易编号发请求创建订单。
2. 成功返回订单编号，然后把订单编号携带路由跳转到订单支付页面。



## 支付页面也需要支付信息

1. 在beforeMount里面将订单编号存储到data上，mounted根据订单编号发送请求获取支付信息，页面展示订单编号和订单编号。
2. 订单编号信息也可以直接通过query参数获取到。



## 点击订单支付会出现一个支付二维码

1. element-ul按需引入。
2. 支付信息包含一个codeUrl，是用来生成二维码的。
3. 安装node-qrcode，用于把返回的图片地址生成二维码。



## 支付流程

1. 生成二维码。
2. messageBox展示二维码。
3. 立马轮询，每隔2秒发一次，去查询支付状态是否支完成。
4. 后台会在发请求后返回支付状态码 ，支付状态码如果是205代表还在支付中，如果是200代表支付成功。
5. 根据返回的状态码绝对后续操作。
   1. 如果是200的时候，我们要自动跳转到支付成功页面，关闭messageBox,并且清除定时器让变量也为null。
   2. 把这个状态码还要保存在data当中，用来去作为用户点击已成功支付按钮的判断依据。
6. 去单独的处理点击我已成功支付或者支付遇到问题按钮的逻辑。
   1. 点击我已成功支付，那么要根据data当中存储的状态码判断是否真的支付完成，如果没有完成，停在当前页面并提示用户,不关闭messageBox。
   2. 点击支付遇到问题，那么我们要提示用户找谁处理，停止往后台发请求，关闭定时器让变量也为null。



## 生命周期

1. `beforeCreate`：无法通过vm访问到data中的数据、methods中的方法。
2. 数据代理，数据劫持
3. `created`：可以通过vm访问到data中的数据、methods中的方法。
4. `beforeMoute`：不能通过ref拿到真实DOM`
5. `Mouted`：可以通过ref拿到真实DOM
6. `beforeUpdate`：data更新了，页面还没更新
7. `Updated`：都更新了
8. `$destroyed`: 通过调用这个方法触发最后两个生命周期方法
9. `beforeDestroy`：一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。
10. `destroyed`：组件真的被销毁了